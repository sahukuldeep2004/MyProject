====================================================SpringFramwork ========================== =============================================================================================

Spring MVC and REST Annotation?
www.java67.com/2019/04/top-10-spring-mvc-and-rest-annotations-examples-java.html#at_pco=smlwn-1.0&at_si=5cdbb7194383efff&at_ab=per-2&at_pos=0&at_tot=1

Que: When to use Singleton and prototype bean ?
Ans: you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.

Ans: Que: What is life cycle of Spring bean /
Ans: Spring beans are instantiated, configured, wired and managed by IoC container.

Que: AOP, Aspect Oriented Programming?
Ans: A cross-cutting concern such as transaction management, authentication, logging, security etc is a concern that could affect the whole application and should be 
centralized in one location in code as much as possible for security and modularity purposes.
Que: What is join point?
https://stackoverflow.com/questions/15447397/spring-aop-whats-the-difference-between-joinpoint-and-pointcut
Ans: A point during the execution of a program, such as the execution of a method or the handling of an exception. 
In Spring AOP, a join point always represents a method execution.
eg.: A method in Employe calss like geName() or getDepartmentname().
this regular expression is what defines Pointcut. e.g.
* * mypackage.Employee.get*(*)

Que: What is an advice? Explain its types in spring?
Ans: An advice is the implementation of cross-cutting concern can be applied on other modules of the spring application. 
Advices are of mainly 5 types.

1. Before :This advice executes before a join point, but it does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception).To use this, use @Before annotation.
2. AfterReturning :This advice is to be executed after a join point completes normally i.e if a method returns without throwing an exception.
To use this, use @AfterReturning annotation.
3. AfterThrowing :This advice is to be executed if a method exits by throwing an exception.To use this, use @AfterThrowing annotation.
4. After :This advice is to be executed regardless of the means by which a join point exits (normal return or exception encounter).
To use this, use @After annotation.
5. Around :This is the most powerful advice surrounds a join point such as a method invocation.
To use this, use @Around annotation.

Que: @Autowiring ?
Ans: The @Autowired annotation in spring automatically injects the dependent beans into the associated references of a POJO class. This annotation will inject the dependent beans by matching the data-type.
Que: @component, @controller, @service, @repository
@component : which automatically scans and registers classes as Spring bean which is annotated using @Component annotation.
@controler: This is specialized form of @Component annotation for certain situations. Instead of using @Component on a controller class in Spring MVC, we use @Controller,
 which is more readable and appropriate. It used for presentaion layer.

@services: It is used for services layer.
@Repository is a stereotype for the persistence layer.

Read more: https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html#ixzz6vZ5sKVbl

Read more: https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html#ixzz6vZ55UI8v

Read more: https://javarevisited.blogspot.com/2017/11/difference-between-component-service.html#ixzz6vZ3z9G4u
Que: How to add bean dependncy for 2 class which Implements same Interface?
Ans:public interface MyService {   void doWork(); }

@Service
@Qualifier("firstService")
public static class FirstServiceImpl implements MyService {
    @Override
    public void doWork() {
        System.out.println("firstService work");
    }
}

@Service
@Qualifier("secondService")
public static class SecondServiceImpl implements MyService {
    @Override
    public void doWork() {
        System.out.println("secondService work");
    }
}

@Component
public static class FirstManager {
    private final MyService myService;
    @Autowired // inject FirstServiceImpl
    public FirstManager(@Qualifier("firstService") MyService myService) {
        this.myService = myService;
    }

    @PostConstruct
    public void startWork() {
        System.out.println("firstManager start work");
        myService.doWork();
    }

}
Que : How to add scope in Spring using anntaion?
Ans: @Bean
@Scope("singleton")
public Person personSingleton() {
    return new Person();
}
in xml  : <bean id="personSingleton" class="org.baeldung.scopes.Person" scope="singleton"/> 

Que:Name some of the design patterns used in Spring Framework?
Ans: Singleton Pattern: Creating beans with default scope.
Factory Pattern: Bean Factory classes
Prototype Pattern: Bean scopes
Adapter Pattern: Spring Web and Spring MVC
Proxy Pattern: Spring Aspect Oriented Programming support
Template Method Pattern: JdbcTemplate, HibernateTemplate etc
Front Controller: Spring MVC DispatcherServlet
Data Access Object: Spring DAO support
Dependency Injection and Aspect Oriented Programming

Que: Diffrence b/w singleton and prototype bean ?
Ans:Singleton: Only one instance will be created for a single bean definition per Spring IoC container and the same object will be shared for each request made for 
that bean. 
Prototype: A new instance will be created for a single bean definition every time a request is made for that bean.
eg. For shopping cart app, each cart object is created for each user.

Que: Diffrence between IOC and Dependency injection ?
Ans: IoC is a generic term meaning rather than Giving control to the container to create and inject instances of objects that your application depend upon, means instead of you are creating an object using the new operator, let the container do that for you.
DI is a form of IoC, where implementations are passed into an object through constructors/setters/service look-ups, which the object will 'depend' on
in order to behave correctly.

Que: Spring MVC Execution flow ?

In Spring Web MVC, DispatcherServlet class works as the front controller. It is responsible to manage the flow of the spring mvc application.
The @Controller annotation is used to mark the class as the controller
The @RequestMapping annotation is used to map the request url.

Step 1: First request will be received by DispatcherServlet.
Step 2: DispatcherServlet will take the help of HandlerMapping and get to know the Controller class name associated with the given request.
Step 3: So request transfer to the Controller, and then controller will process the request by executing appropriate methods and returns ModelAndView object 
(contains Model data and View name) back to the DispatcherServlet.
Step 4: Now DispatcherServlet send the model object to the ViewResolver to get the actual view page.
Step 5: Finally DispatcherServlet will pass the Model object to the View page to display the result.

Que: What is beanFactory ?
Ans: Bean Factory is core of the spring framework and, it is a Lightweight container which loads bean definitions and manages your beans. Beans are configured using XML file and manage singleton defined bean. It is also responsible for life cycle methods and injects dependencies. It also removes adhoc singletons and factories.

Que: How to configuer Spring data JPA in non spring boot project?
Ans:To use spring data we need to configure following objects:

DataSource: Database configuration- URL, username, password, driver, etc
EntityManager: Most important object which binds all objects, like entity package, datasource, etc
 - we can configure entityManager using LocalEntityManagerFactoryBean
 - we can also configure additional properties using setJpaProperties(properties)
TransactionManager: Configuration for database transaction
Configuration using java code:
@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {


Programimg interview Question
http://www.java67.com/2013/01/10-programming-questions-and-exercises.html

sonarlint for code quality plug-in
jacoco(Java code coverage) plug-in for code coverage reort in sonarcube. It will generate the report and say about which method is not covered by junit tetsing.

testing approaches TDD, BDD
