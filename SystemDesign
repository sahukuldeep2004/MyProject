No matter your programming language, start by understanding the basics of how systems are designed.

👍 𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐊𝐞𝐲 𝐂𝐨𝐧𝐜𝐞𝐩𝐭𝐬
1. Scalability: https://lnkd.in/gpge_z76
2. Latency vs Throughput: https://lnkd.in/g_amhAtN
3. CAP Theorem: https://lnkd.in/g3hmVamx
4. ACID Transactions: https://lnkd.in/gMe2JqaF
5. Rate Limiting: https://lnkd.in/gWsTDR3m
6. API Design: https://lnkd.in/ghYzrr8q
7. Strong vs Eventual Consistency: https://lnkd.in/gJ-uXQXZ
8. Distributed Tracing: https://lnkd.in/d6r5RdXG
9. Synchronous vs. asynchronous communications: https://lnkd.in/gC3F2nvr
10. Batch Processing vs Stream Processing: https://lnkd.in/g4_MzM4s
11. Fault Tolerance: https://lnkd.in/dVJ6n3wA

👍 𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐁𝐮𝐢𝐥𝐝𝐢𝐧𝐠 𝐁𝐥𝐨𝐜𝐤𝐬
1. Databases: https://lnkd.in/gti8gjpz
2. Horizontal vs Vertical Scaling: https://lnkd.in/gAH2e9du
3. Caching: https://lnkd.in/gC9piQbJ
4. Distributed Caching: https://lnkd.in/g7WKydNg
5. Load Balancing: https://lnkd.in/gQaa8sXK
6. SQL vs NoSQL: https://lnkd.in/g3WC_yxn
7. Database Scaling: https://lnkd.in/gAXpSyWQ
8. Data Replication: https://lnkd.in/gVAJxTpS
9. Data Redundancy: https://lnkd.in/gNN7TF7n
10. Database Sharding: https://lnkd.in/gMqqc6x9
11. Database Index's: https://lnkd.in/gCeshYVt
12. Proxy Server: https://lnkd.in/gi8KnKS6
13. WebSocket: https://lnkd.in/g76Gv2KQ
14. API Gateway: https://lnkd.in/gnsJGJaM
15. Message Queues: https://lnkd.in/gTzY6uk8

👍 𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐀𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐚𝐥 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬
1. Event-Driven Architecture: https://lnkd.in/dp8CPvey 
2. Client-Server Architecture: https://lnkd.in/dAARQYzq
3. Serverless Architecture: https://lnkd.in/gQNAXKkb
4. Microservices Architecture: https://lnkd.in/gFXUrz_T

➤ 𝗕𝗮𝘀𝗶𝗰𝘀 𝗼𝗳 𝗦𝘆𝘀𝘁𝗲𝗺 𝗗𝗲𝘀𝗶𝗴𝗻
 • What is System Design?
 • Functional vs Non Functional Requirements
 • What are the components of System Design?
 • System Design Life Cycle | SDLC (Design)
 • Structured Analysis and Structured Design
 • System Design Strategy
 • Database Sharding - Concept
 • Horizontal and Vertical Scaling
 • Load Balancer in System Design
 • Routing requests through Load Balancer
 • Latency and Throughput in System Design
 • Object-Oriented Analysis and Design
 • Difference between Structured and Object-Oriented Analysis

➤ 𝗟𝗼𝘄 𝗟𝗲𝘃𝗲𝗹 𝗗𝗲𝘀𝗶𝗴𝗻 (𝗟𝗟𝗗)
 • What is Low Level Design or LLD
 • Data Structures and Algorithms for System Design
 • Event-Driven Architecture
 • Difference between Authentication and Authorization
 • What is API Gateway
 • What is Data Encryption?
 • Design Patterns
 • Code Optimization Techniques
 • Unit Testing
 • Integration Testing
 • CI/CD: Continuous Integration and Continuous Delivery
 • Introduction to Modularity and Interfaces In System Design
 • Data Partitioning Techniques
 • Class Diagrams | UML

➤ 𝗛𝗶𝗴𝗵 𝗟𝗲𝘃𝗲𝗹 𝗗𝗲𝘀𝗶𝗴𝗻 (𝗛𝗟𝗗)
 • What is High Level Design
 • Availability in System Design
 • Consistency in System Design
 • Reliability in System Design
 • CAP Theorem
 • Difference between Process and Thread
 • Difference between Concurrency and Parallelism
 • Load Balancer
 • Consistent Hashing
 • Content Delivery Network (CDN) in System Design
 • Caching in System Design
 • Cache Eviction Policies
 • Message Queues
 • Communication Protocols
 • Network Protocols and Proxies in System Design
 • Unified Modeling Language (UML)

➤ 𝗗𝗼 𝗧𝗵𝗲𝘀𝗲 𝗤𝘂𝗲𝘀𝘁𝗶𝗼𝗻𝘀
 • Design URL Shortening Service
 • Design Dropbox
 • Design Twitter
 • System Design Netflix - A Complete Architecture
 • System Design of Uber App - Uber System Architecture
 • Design Book My Show
 • Designing Facebook Messenger
 • Designing WhatsApp Messenger
 • Designing Instagram

Data Replication:
Data replication also known as database replication, is a method of copying data to ensure that all information stays 
identical in real-time between all data resources.

Partitioning
Split large tables into smaller, more manageable pieces to improve query performance and maintenance.
It is the process of splitting a database table into multiple logical units, or partitions, that are stored separately on disk.
eg. in table of employee, we can store emp_id 1 to 10,000 in table employee_partition_1 and empId 10,001 to 20,000 in table employee_partition_2.
There are several types of partitioning, including RANGE, LIST, and KEY. Above example is range one.
When data is written to the table, a partitioning function will be used by MySQL to decide which partition to store the data in. 
The value for one or more columns in a given row is used for this sorting process.

Sharding :
Sharding is a method for distributing a single dataset across multiple databases, which can then be stored on multiple 
machines. This allows for larger datasets to be split into smaller chunks and stored in multiple data nodes, 
increasing the total storage capacity of the system. Sharding is a form of scaling known as horizontal scaling or 
scale-out, as additional nodes are brought on to share the load.

Database indexes:
An index is a database structure that you can use to improve the performance of database activity. A database table can 
have one or more indexes associated with it.
An index is defined by a field expression that you specify when you create the index. Typically, the field expression 
is a single field name, like emp_id. An index created on the emp_id field, for example, contains a sorted list of 
the employee ID values in the table. Each value in the list is accompanied by references to the rows that contain 
that value.
A database driver can use indexes to find rows quickly. An index on the emp_id field, for example, greatly reduces the 
time that the driver spends searching for a particular employee ID value. Consider the following Where clause:
WHERE EMP_id = 'E10001'
Without an index, the server must search the entire database table to find those rows having an employee ID of E10001.
By using an index on the emp_id field, however, the server can quickly find those rows.

Proxy:
Forward proxy :
Operates between clients and external systems, protecting the client's identity and managing client-side requests
Forward proxies can hide the device's IP address by assigning one of its IP addresses
Reverse proxy
Operates between clients and servers, protecting server-side interests.Reverse proxies can manage load balancing and routing. 

Websocket :
WebSockets is a communication protocol providing full-duplex, bidirectional communication channels over a single, 
long-lived TCP connection. It enables real-time data exchange between a client (e.g., web browser) and a server with 
low overhead, reducing latency compared to traditional HTTP-based techniques like polling or long polling. WebSocket 
connections are established through a WebSocket handshake initiated over HTTP/HTTPS using the ws:// or wss:// URL schemes, 
then upgraded to the WebSocket protocol. Commonly used in applications like chat, gaming, IoT, and live updates. 
WebSockets supports both binary and text data formats.

API Gateway :
An API gateway accepts API requests from a client, processes them based on defined policies, directs them to the 
appropriate services, and combines the responses for a simplified user experience. Typically, it handles a request 
by invoking multiple microservices and aggregating the results. It can also translate between protocols in legacy 
deployments.
For microservices‑based applications, an API gateway acts as a single point of entry into the system. It sits in front 
of the microservices and simplifies both the client implementations and the microservices app by decoupling the 
complexity of an app from its clients.
In a microservices architecture, the API gateway is responsible for request routing, composition, and policy enforcement. 
It handles some requests by simply routing them to the appropriate backend service, and handles others by invoking 
multiple backend services and aggregating the results.
An API gateway might provide other capabilities for microservices such as authentication, authorization, monitoring, 
load balancing, and response handling, offloading implementation of non-functional requirements to the infrastructure 
layer and helping developers to focus on core business logic, speeding up app releases.

MQ: A message queue is a queue of messages sent between applications. It includes a sequence of work objects that are waiting to be processed.
RabbitMQ consists of:
1. producer — the client that creates a message
2. consumer — receives a message
3. queue — stores messages
3. exchange — enables to route messages and send them to queues
The system functions in the following way:
1. producer creates a message and sends it to an exchange
2. exchange receives a message and routes it to queues subscribed to it
3. consumer receives messages from those queues he/she is subscribed to
One should note that messages are filtered and routed depending on the type of exchange
