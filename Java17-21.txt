=======================java 17 Feature==================

Record class : It was first introduced in Java 14 as a preview feature, and finalized in Java 17. It has added new keyword 'record' in the list of java keyword.
WHAT : A record in Java is a class that is intended to store data.Records are immutable by default, which means that their state cannot be changed once they are created. This makes them ideal for storing data that should not be modified (immutable data), such as configuration settings or values returned from a database query.

WHEN To USE: If you want to transfer immutable data between different layers of your application, then using a record in Java can be a good choice.By default, Records are immutable in Java, which means that we can’t change their properties after they are created.

WHERE TO USE : eg; DTOs, API response,
Exmaple Syntax: public record Book(String name, double price) { }
This creates a new record called “Book” with two fields: “name” and “price”.
eg. Book book = new Book("Core Java", 324.25);
String name = book.name(); 
double price = book.price();

We can add a new field, but not recommended. A new field added to the record must be static. For example:
public record Person(String name, int age) {
   static String sex;
}
Canonical Constructor:-Java compiler by default provides us an all-arguments constructor (a constructor with all fields) that assigns its arguments to the corresponding fields. It is known as the canonical constructor. We can also add business logic such as conditional statements to validate data. Below is the example:
public record Person(String name, int age) {
       public Person(String name, int age) {
           if (age < 18) {
              throw new IllegalArgumentException("You are not allowed to participate in general elections");
           }
      }
}
Methods in Records:-In addition to the automatically generated accessor methods, we can also define our own methods in a record, just like in a regular class. For example:
public record Person(String name, int age) { 
   public void sayHello() { 
      System.out.println("Hello, my name is " + name); 
   }
}
Records automatically generate boilerplate code like constructors, accessor methods for components, equals(), hashCode(), and toString() implementations.
https://javatechonline.com/record-in-java-with-examples/#:~:text=Just%20like%20any%20other%20class,be%20specified%20as%20constructor%20parameters.

Pattern Matching for SWITCH statement:
Pattern matching for switch statements and expressions, introduced as a preview feature in Java 17 and finalized in later versions, enhances the switch 
construct by allowing it to match against types and values, not just exact constants.
public class PatternMatchingSwitchExample {

    public static String describeObject(Object obj) {
        return switch (obj) {
            case Integer i -> "It's an Integer with value: " + i;
            case String s -> "It's a String with length: " + s.length();
            case Double d when d > 0 -> "It's a positive Double: " + d;
            case Double d -> "It's a non-positive Double: " + d;
            case null -> "It's null"; // Handling null explicitly
            default -> "It's an unknown type: " + obj.getClass().getName();
        };
    }

    public static void main(String[] args) {
        System.out.println(describeObject(10));
        System.out.println(describeObject("Hello Java"));
        System.out.println(describeObject(3.14));
        System.out.println(describeObject(-2.5));
        System.out.println(describeObject(null));
        System.out.println(describeObject(new Object()));
    }
}
=====================
public class EnhancedSwitchExample {

    // Define a simple enum for demonstration
    enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }

    public static void main(String[] args) {
        Day today = Day.WEDNESDAY;

        // 1. Switch as an expression (returning a value)
        String message = switch (today) {
            case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> "It's a weekday.";
            case SATURDAY, SUNDAY -> "It's the weekend!";
        };
        System.out.println("Message: " + message);

        // 2. Using 'yield' for more complex logic within a case
        String activity = switch (today) {
            case MONDAY -> {
                System.out.println("Starting the work week...");
                yield "Planning meetings";
            }
            case FRIDAY -> {
                System.out.println("Almost the weekend!");
                yield "Finishing tasks";
            }
            case SATURDAY, SUNDAY -> "Relaxing";
            default -> "Working"; // Default case is required for exhaustiveness in switch expressions
        };
        System.out.println("Activity: " + activity);

        // 3. Pattern Matching for switch (Preview Feature in Java 17, standard in Java 21)
        Object obj = "Hello"; // Can be any object type

        String typeDescription = switch (obj) {
            case String s -> "This is a String: " + s.toUpperCase();
            case Integer i -> "This is an Integer: " + i * 2;
            case Day d -> "This is a Day enum: " + d.name();
            case null -> "This is a null object."; // Handling null explicitly
            default -> "Unknown type.";
        };
        System.out.println("Type Description: " + typeDescription);
    }
}
======================================================

Sealed Class & Interface:
Sealed classes and interfaces offer a restriction whether classes/interfaces can extend/implement other classes/interfaces or not.
public sealed class Shape permits Circle, Square, Triangle {
    // ...
}
In the example, the “sealed” modifier is used to specify that the Shape class is a sealed class. The “permits” keyword is then used to specify the 
allowed subclasses of Shape, which are Circle, Square, and Triangle.

By using a sealed class, we can ensure that the only allowed subclasses of Shape are Circle, Square, and Triangle. Any other attempt to extend Shape will 
result in a compilation error.
// Sealed class declaration
public sealed class Shape permits Circle, Square, Triangle {
    // Common behavior or abstract methods can be defined here
    public abstract double calculateArea();
}

// Permitted subclass: final, meaning it cannot be extended further
public final class Circle extends Shape {
    private final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// Permitted subclass: non-sealed, meaning it can be extended by other classes
public non-sealed class Square extends Shape {
    private final double side;

    public Square(double side) {
        this.side = side;
    }

    @Override
    public double calculateArea() {
        return side * side;
    }
}

// Permitted subclass: sealed, meaning it can only be extended by its permitted subclasses
public sealed class Triangle extends Shape permits EquilateralTriangle {
    private final double base;
    private final double height;

    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }

    @Override
    public double calculateArea() {
        return 0.5 * base * height;
    }
}

// Permitted subclass of Triangle
public final class EquilateralTriangle extends Triangle {
    private final double side;

    public EquilateralTriangle(double side) {
        super(side, (Math.sqrt(3) / 2) * side); // Calculate height based on equilateral triangle formula
        this.side = side;
    }
}

// Main class to demonstrate usage
public class SealedClassExample {
    public static void main(String[] args) {
        Shape circle = new Circle(5.0);
        Shape square = new Square(4.0);
        Shape triangle = new Triangle(6.0, 8.0);
        Shape equilateralTriangle = new EquilateralTriangle(7.0);

        System.out.println("Area of Circle: " + circle.calculateArea());
        System.out.println("Area of Square: " + square.calculateArea());
        System.out.println("Area of Triangle: " + triangle.calculateArea());
        System.out.println("Area of Equilateral Triangle: " + equilateralTriangle.calculateArea());

        // Attempting to extend Shape with an unpermitted class would result in a compile-time error.
        // For example:
        // class Pentagon extends Shape {} // This would cause a compile-time error
    }
}

Sealed classes work very well with records. Since records are implicitly final, the sealed hierarchy is even more concise. Let’s try to rewrite our class example using records:

public sealed interface Vehicle permits Car, Truck {
    String getRegistrationNumber();
}

public record Car(int numberOfSeats, String registrationNumber) implements Vehicle {
    @Override
    public String getRegistrationNumber() {
        return registrationNumber;
    }
    public int getNumberOfSeats() {
        return numberOfSeats;
    }
}

public record Truck(int loadCapacity, String registrationNumber) implements Vehicle {
    @Override
    public String getRegistrationNumber() {
        return registrationNumber;
    }
    public int getLoadCapacity() {
        return loadCapacity;
    }
}
